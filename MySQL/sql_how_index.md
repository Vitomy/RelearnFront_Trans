## 深入浅出索引 B+树
数据库索引，一个SQL查询较慢，需要给某个字段加个索引。<br>
### 什么是索引，索引怎么工作？
索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。<br>
#### 索引的常见模型 哈希表、有序数组和搜索树
哈希表: key-value存储数据的结构，只要输入待查询的的值即key，就可以找到其对应的值即Value。<br>
拉链法，有序数组索引只适用于静态存储引擎。<br>
##### 多叉树 读写性能优，适配磁盘访问模式
在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。<br>
InnoDB的索引模型，表都是根据主键顺序以索引的形式存放的(索引组织表)。使用B+树索引模型，数据都存储在B+树中。<br>
**每一个索引在InnoDB里面对应一颗B+树。** 假设，主键列为ID的表，表中有字段K，并且K上有索引。
```shell
create table T(id int primary key,k int not null,name varchar(16),index (k))engine = InnoDB;
```
ID有索引，K有索引，ID为主键索引，K为非主键索引。主键索引的叶子节点存的是整行数据。InnoDB，主键索引也被称为聚簇索引(clustered index)<br>
非主键索引的叶子节点内容是主键的值。InnoDB，非主键索引也被称为二级索引。<br>
* 区别: `select * from T where ID = 500`搜索ID这颗B+树
* 区别: `select * from T where k = 5` 普通索引查询方式，搜索K，然后得到ID值为500，再回表查询ID索引树

**所以尽量使用主键查询**<br>

#### 索引维护 维护B+树的有序性，插入新值需要做必要的维护
B+树的数据插入可能会引起数据页分裂，当删除了页的数据就需要合并。二者都是较重IO消耗，所以比较好的方式是顺序插入数据，这也是为什么使用自增主键的原因。<br>
**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小** 自增主键往往是更合理的选择。避免查询多棵树。<br>
如若执行 `select * from T where k between 3 and 5`，需执行几次树的搜索操作。会扫描多少行。执行查询k=3与k=5操作，然后再到ID树寻找ID=300对应的数据，回表操作，然后再寻找k=6，不满足条件，循环结束。<br>
#### 覆盖索引 已经存在K索引树上，直接返回结果，不需要回表 减少树的搜索次数
显著提升查询性能。
一个问题❓在一个市民信息表上，是否有必要将身份证号和姓名建立联合索引❓如果需要根据身份证号查询姓名，这个联合索引就有意义。<br>
#### 最左前缀原则
如果现在需要按照身份证号查询家庭地址，则这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描！单独为一个不频繁的查找建立一个索引，就会有点浪费。<br>
B+树索引结果，可以利用索引的"最左前缀"，定位记录。<br>
```
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB

```
#### 联合索引
`(name,age)`联合索引来分析。定位联合索引最左N个字段，也可以是字符串索引的最左M个字符。在建立联合索引的时候，如何安排索引内的字段顺序❓<br>
第一原则，如果可以通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑的。
#### 索引下推 
```
mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
```
MySQL5.6下推优化，自行判断age的值，然后减少回表次数<br>

尽量少地访问资源是数据库设计的重要原则之一。<br>
删除主键还是创建主键，整个表的索引都会重建。可以使用`alter table T engine = InnoDB`;<br>
索引越多，维护成本越大。<br>

