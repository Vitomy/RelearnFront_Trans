### count的实现流程
不同的MySQL引擎，count(*)有不同的实现方式<br>
* MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率高
* InnoDB，需要将数据一行一行地读取，然后累计

为什么InnoDB不跟MyISAM一样，也把数字存起来？因为即使是在同一个时刻的多个查询，由于多版本并发控制(MVCC)的原因，InnoDB应该返回多少行也是不确定的。<br>

多个事务由于可重复读隔离级别，所以需要MVCC实现。每一行记录都需要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地独处依次判断，可见的行才能够用于计算基于这个查询的表的总行数<br>

优化器进行优化，尽量减少扫描的数据量，找最小的一棵树来遍历。<br>

show table status显示的行数不准，因为通过采样估算的。<br>

Redis容易发生计数不准确的问题，不能解决一致性视图，不支持分布式事务<br>

在数据库保存计数，单独一张计数表，两个会话的结果，逻辑上是一致的<br>

更新会涉及行锁，先插入，再更新计数值最大程度减少事务之间的锁等待，提高并发度。<br>

count()是一个聚合函数，对于返回的结果集，一行一行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值。

* server层要什么就给什么
* InnoDB只给必要的值
* 现在的优化器只优化了count(*)的语义为取行数，其他显而易见的优化并没有做

* count(主键id) 遍历整张表，返回给server层。server层拿到id后，判断就不可能为空，按行累加
* count(1) 遍历整张表但是不取值。server层对于返回的每一行，放一个数字“1”，进去，判断是不可能为空，按行累加
* count(字段) not null，就需要读出这个字段，判断不能为null，按行累加。 定义为null，判断可能是null，取出值，然后判断不为null才累加

* count(*)，判断不是null，按行累加

count(*)性能更好！<br>
