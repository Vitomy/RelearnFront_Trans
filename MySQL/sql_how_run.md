## 一条SQL查询语句是如何执行的？
不动笔墨不读书系列<br>
![MySQL基本架构示意图](./img/run_process.png)

从上面的模块可以看出各个功能模块的执行过程。<br>
大体来说，MySQL可以分为Server层和存储引擎层两部分。<br>
Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL大多数核心服务功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、试图等。<br>
存储引擎层负责数据的存储和提取。其架构模式是插件式，支持InnoDB、MyISAM、Memory等多个存储引擎。**常用存储引擎是InnoDB**。<br>
create table建表若不指定引擎类型，默认使用的就是InnoDB。(engine=InnoDB)。<br>
不同存储引擎的表数据存储方式不同，支持的功能也不同。<br>
不同的存储引擎公用一个Server层，也就是从连接器到执行器的部分。<br>
#### 连接器 链接数据库 连接器负责跟客户端建立链接、获取权限、维持和管理链接
```shell
mysql -u root -p
```
完成经典的TCP握手，就开始认证身份<br>
一个用户成功建立链接，就使用该有的权限，即使修改，也只能下一次生效。<br>
客户端在链接后太长时间没有动静，连接器将自动断开。默认8小时<br>
断开后，就需要继续重连，再执行请求。<br>
**长链接** 客户端持续有请求，一直使用同一个链接。**短链接** 每次执行很少的几次查询就断开链接，下一次查询再重新建立一个。<br>
长链接会导致MySQL占用内存涨得特别快，因为在MySQL在执行过程中临时使用的内存是管理在链接对象里面的。内存过大，系统强行杀掉，MySQL异常重启。<br>
1.定期断开长链接 2. MySQL5.7 后版本可以执行mysql_reset_connection来重新初始化链接资源。将链接回复到刚刚创建完时的状态。<br>
#### 查询缓存 执行第二步，查询缓存
之前执行股耦的语句，可能会以key-value对形式缓存在内存中。如果查询key，之前执行的语句，value就是查询后的结果，直接缓存在内存中。<br>
大多数情况下建议不要使用查询缓存，因为查询缓存往往弊大于利。(select SQL_CACHE *from T where ID = 10;)。因为更新了表，查询你缓存就会被清空。而且命中率低。<br>
可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句就不使用查询缓存。<br>
MySQL8.0 版本直接将查询缓存的整块功能删掉了。<br>

#### 分析器 如果没有命中查询缓存就需要执行语句 首先需要分析
分析器做词法分析，然后语法分析，错误会提醒
#### 优化器 优化器处理 表里面的索引会用那个索引，或者join的时候，决定各个表的链接顺序
执行逻辑结果一样，但是执行的效率不同，让优化器决定使用那个方案

#### 执行器阶段
先查询有没有执行查询的权限。如果有权限就继续打开表执行，根据引擎定义，使用这个引擎提供的接口。<br>
rows_examined字段，可以看到语句执行过程中扫描了多少行。<br>


