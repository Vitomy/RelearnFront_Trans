## JavaScript学习历程
嗯...不知道怎么总结这个js😢。作为一种弱类型脚本语言，从执行上下文➡️变量对象➡️作用域链闭包➡️this➡️chrome浏览器优化➡️函数式编程➡️函数柯里化➡️面向对象、构造函数、原型与原型链➡️面向对象实战➡️jquery扩展插件➡️事件循环机制➡️Promise实现➡️ES6大门<br>
好像每个知识点都知道，倒是深入了解不了。所以需要深入了解，掘金，简书，知乎以及高级程序设计，让知识深深刻在大脑里。<br>
最后深入理解Node➡️Koa➡️浏览器优化➡️MySQL➡️重学前端<br>
### js内存空间详细
结合队列，栈，堆内存，栈存储变量对象，堆存储对象，引用设计。脱离执行环境，垃圾会进行收集。<br>
[javascript内存空间详解，传送门](https://www.jianshu.com/p/996671d4dcc4)
### 执行上下文详细
[执行上下文详细，传送门](https://www.jianshu.com/p/a6d37c77e8db)

Execution Context执行上下文
```js
console.log(a);
var a = 20;
```
每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，会形成一个作用域。
* 全局环境: JS代码运行起来会首先进入该环境
* 函数环境: 当函数被调用执行时，会进入当前函数中执行代码
* eval

JS引擎会以栈的方式处理多个执行上下文，栈可称为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。<br>

按出栈顺序执行。单线程，同步执行，只有栈顶上下文处于执行中，其他上下文需要等待，全局上下文只有唯一一个，浏览器关闭时出栈，函数的执行上下文的个数没有限制。每次某个函数被调用，就会有一个新的执行上下文为其创建，即使是调用自身函数。<br>

### 变量对象详解
[变量对象详解，传送门](https://www.jianshu.com/p/330b1505e41d)

当一个函数激活时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。<br>
* 创建阶段 执行上下文分别创建变量对象，建立作用域链，以及确定this指向。
* 执行阶段 创建之后，剋是执行代码，完成变量赋值，函数引用，以及执行其他代码

变量对象创建过程需要熟悉一下。<br>

变量对象和活动对象，都是同一个对象，只是处于执行上下文不同的生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。<br>

function声明会比var声明优先级更高一点。
```js
function test(){
    console.log(a);
    console.log(foo());
    var a = 1;
    function foo(){
        return 2;
    }
}
test();
```
test()执行上下文开始理解，创建过程，进入testEC
```js
testEC = {// 变量对象
    VO:{},
    scopeChain:{}
}
VO = {arguments:{...}//注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理
,foo:<foo reference>,a:undefined}
```
在未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段，变量对象就转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作<br>
执行阶段
```js
VO->AO
AO = {
    arguments:{...},
    foo:<foo reference>,
    a:1,
    this:window
}
```
几个例子比较通俗易懂。<br>

### 详细作用域链与闭包
[作用域链与闭包，传送门](https://www.jianshu.com/p/21a16d44f150)
